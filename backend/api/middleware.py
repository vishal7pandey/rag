"""HTTP request/response logging and tracing middleware.

Story 005 introduces this middleware to attach a correlation ID (trace ID) to
all requests and to emit structured request/response logs using the core
logging utilities.
"""

from __future__ import annotations

import time
import uuid
from datetime import datetime, timezone
from typing import Callable, Awaitable

from fastapi import Request, Response
from starlette.middleware.base import BaseHTTPMiddleware

from backend.core.logging import get_logger
from backend.core.tracing import TraceContext


logger = get_logger("rag.api.middleware")


class LoggingMiddleware(BaseHTTPMiddleware):
    """Middleware that adds tracing and request/response logging.

    Responsibilities
    ----------------
    1. Extract or generate a trace ID from the incoming request.
    2. Bind a :class:`TraceContext` into ``contextvars`` for downstream code.
    3. Log a "request_received" event.
    4. Call the next handler and measure latency.
    5. Log a "response_sent" event, including status code and latency.
    6. Add the trace ID to the ``X-Trace-ID`` response header.
    """

    async def dispatch(
        self,
        request: Request,
        call_next: Callable[[Request], Awaitable[Response]],
    ) -> Response:
        # Extract existing trace ID or generate a new one.
        trace_id = request.headers.get("X-Trace-ID", str(uuid.uuid4()))
        user_id = request.headers.get("X-User-ID", "anonymous")
        request_id = (
            f"req-{datetime.now(timezone.utc).strftime('%Y%m%d-%H%M%S')}-"
            f"{uuid.uuid4().hex[:8]}"
        )

        # Create and bind trace context for downstream components.
        ctx = TraceContext(trace_id=trace_id, user_id=user_id, request_id=request_id)
        ctx.set_context_vars()

        # Log request entry.
        logger.info(
            "request_received",
            extra={
                "context": {
                    "method": request.method,
                    "path": request.url.path,
                    "query_string": str(request.url.query),
                    "trace_id": trace_id,
                    "user_id": user_id,
                    "client_ip": request.client.host if request.client else "unknown",
                }
            },
        )

        start_time = time.time()
        response: Response | None = None

        try:
            response = await call_next(request)
        finally:
            latency_ms = (time.time() - start_time) * 1000
            status_code = response.status_code if response is not None else 500

            logger.info(
                "response_sent",
                extra={
                    "context": {
                        "method": request.method,
                        "path": request.url.path,
                        "status_code": status_code,
                        "latency_ms": round(latency_ms, 2),
                        "trace_id": trace_id,
                        "user_id": user_id,
                    }
                },
            )

        # Ensure a response object exists; if not, re-raise so the global
        # error handler can create one.
        if response is None:
            raise RuntimeError("Response was not generated by downstream handler")

        response.headers["X-Trace-ID"] = trace_id
        return response
